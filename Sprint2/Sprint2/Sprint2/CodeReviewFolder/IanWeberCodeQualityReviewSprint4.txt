Author of the code review: Ian Weber
Date of the code review: 11/2/2015
Sprint number: 4
Name of the .cs file being reviewed: Mario (and related state classes)
Author of the .cs file being reviewed:  Matthew Mohr
Number of minutes taken to complete the review: 20 min
Details:
For this maintainability review, let's take a look at the process required for updating Mario and its related classes.  First of all,
nice job on changing the state changes logic for Mario to a new format to fix some of the bugs that were evident with the previous iteration.  
A transition time variable for each of the possible Mario states exists in the Mario class as a private variable.  So a transition time for Big,
Fire, Small, DifferentDirection, etc.  These private variables (floats, specifically) are then used in Mario's Draw method for the logic to change
his state.  This fixes some of the bugs that were occurring with his state changes for some weird edge cases.  They are compared to the transition
duration, which can be easily changed depending on the state he is in and the target state.  So, everything regarding Marios state changes appear
inside the Mario class.  Makes good sense, right?  Mario's only publicly available properties are still his state information, but this is enough
to have it interact with the game appropriately and allow for all of his states to occur.  The class is still less than 300 lines of code, which is
impressive.  Now, the Mario state classes take in an existing Mario in their constructors, which may seem confusing at first, but is actually quite
simple and effective.  Since we have access to Mario's existing state and location as public properties, the logic for actually drawing the new 
Mario sprite can take place in the Mario state classes.  This is a bit taxing to update/maintain, but in reality it only adds a slight bit more
code/logic to each class, which is very easy to understand.  Matt's design is like the "factory", but one that can take in an existing Mario and look
at it's current properties to change it.  For one example, in the MarioJump (implements an IMarioState) class, in the constructor is input for the 
current Mario.  In the MarioJump Update() method, now based on Mario's current state, the next Mario to be drawn is given.  Mario becomes his new 
state depending on if he was small, big, and which direction he was facing, and it is drawn as the correct sprite accordingly.  Overall, this design
adds only a few extra methods per class, and the logic is easy to understand.  Granted, this would be a taxing design if the game featured many more
states and possible state transitions, but since it is a simple game this design has worked out well for us.  All Mario classes are of reasonable
length and understandability, and are going to be easy to maintain for sprint 5 and 6.